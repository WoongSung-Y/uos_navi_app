import React, { useEffect, useState, useRef } from 'react';
import { View, StyleSheet } from 'react-native';
import MapView, { Marker, Polygon, Polyline } from 'react-native-maps';
import { Menu, Provider } from 'react-native-paper';
import { fetchFloorPolygons, fetchShortestPath, fetchNodes, fetchEdgeCoordinates } from '../services/api';
import { findNearestNode } from '../utils/findNearestNode';

const MapComponent = ({ 
  buildingPolygon, 
  selectedBuilding, 
  setSelectedBuilding, 
  selectedFloor,
  startLocation, 
  endLocation, 
  setStartLocation, 
  setEndLocation 
}: any) => {
  const [floorPolygons, setFloorPolygons] = useState<any[]>([]);
  const [menuVisible, setMenuVisible] = useState(false);
  const [menuPosition, setMenuPosition] = useState<{ x: number; y: number } | null>(null);
  const [selectedCoords, setSelectedCoords] = useState<{ latitude: number; longitude: number } | null>(null);
  const [path, setPath] = useState<any[]>([]);
  const [nodes, setNodes] = useState<any[]>([]);
  const mapRef = useRef<MapView>(null);

  // ÏÑ†ÌÉùÎêú Í±¥Î¨ºÍ≥º Ï∏µÏùÑ ÏÑúÎ≤Ñ DBÏóêÏÑú Î∂àÎü¨ÏôÄÏÑú
  // floorPolygons stateÏóê Ï†ÄÏû•
  useEffect(() => {
    const loadFloorPolygons = async () => {
      if (selectedBuilding) {
        const data = await fetchFloorPolygons(selectedFloor, selectedBuilding);
        setFloorPolygons(data);
      }
    };
    loadFloorPolygons();
  }, [selectedBuilding, selectedFloor]);

  // ÎÖ∏Îìú Îç∞Ïù¥ÌÑ∞Î•º ÏÑúÎ≤Ñ DBÏóêÏÑú Î∂àÎü¨ÏôÄÏÑú
  // nodes stateÏóê Ï†ÄÏû•
  useEffect(() => {
    const getNodes = async () => {
      const data = await fetchNodes();
      setNodes(data);
    };
    getNodes();
  }, []);


  // ÏµúÎã® Í≤ΩÎ°ú Í≥ÑÏÇ∞
  useEffect(() => {
    const getRoute = async () => {
      if (startLocation && endLocation && nodes.length > 0) {
        console.log("üì° Ï∂úÎ∞úÏßÄ & ÎèÑÏ∞©ÏßÄ GPS Ï¢åÌëú:", startLocation, "‚Üí", endLocation);
        
        // ÏãúÏûë, Ï∂úÎ∞ú ÎÖ∏Îìú ÏÑ†ÌÉù
        const startNode = findNearestNode(nodes, startLocation.latitude, startLocation.longitude, 'outdoor');
        const endNode = findNearestNode(nodes, endLocation.latitude, endLocation.longitude, 'outdoor');
        
        if (!startNode || !endNode) {
          console.error("‚ùå Ï∂úÎ∞úÏßÄ ÎòêÎäî ÎèÑÏ∞©ÏßÄÏùò Í∞ÄÏû• Í∞ÄÍπåÏö¥ ÎÖ∏ÎìúÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
          return;
        }
    
        console.log(`üöÄ Ï∂úÎ∞ú ÎÖ∏Îìú: ID=${startNode.node_id}, ÏúÑÎèÑ=${startNode.latitude}, Í≤ΩÎèÑ=${startNode.longitude}`);
        console.log(`üèÅ ÎèÑÏ∞© ÎÖ∏Îìú: ID=${endNode.node_id}, ÏúÑÎèÑ=${endNode.latitude}, Í≤ΩÎèÑ=${endNode.longitude}`);
    
        // ÏµúÎã® Í≤ΩÎ°ú Í≥ÑÏÇ∞
        // fetchShorttestPathÏóê Ï∂úÎ∞ú, ÎèÑÏ∞©, type ÏöîÏ≤≠
        const shortestPath = await fetchShortestPath(startNode.node_id, endNode.node_id, 'outdoor');
        if (shortestPath.length === 0) {
          console.error("‚ö†Ô∏è [ERROR] ÏµúÎã® Í≤ΩÎ°úÍ∞Ä ÏóÜÏùå!");
          return;
        }
    
        console.log("üìç ÏµúÎã® Í≤ΩÎ°ú Îç∞Ïù¥ÌÑ∞:", JSON.stringify(shortestPath, null, 2));
    
        // ÏµúÎã®Í≤ΩÎ°úÏóêÏÑú EdgeID(ÎßÅÌÅ¨ ID) Ï∂îÏ∂ú
        // EdgeID: ÎèÑÎ°ú ÎÑ§Ìä∏ÏõåÌÅ¨ÏóêÏÑú Ïó∞Í≤∞Îêú Í∏∏
        const edgeIds = shortestPath.map(node => node.edge);
        console.log("üìç Edge ID Î™©Î°ù:", edgeIds);
    
        // EdgeIDÏóê Ìï¥ÎãπÌïòÎäî ÎßÅÌÅ¨ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
        const edges = await fetchEdgeCoordinates(edgeIds);
        console.log("üì° [DEBUG] edges Îç∞Ïù¥ÌÑ∞ (JSON Ï†ÑÏ≤¥ Ï∂úÎ†•):", JSON.stringify(edges, null, 2));
        
        // ÎßÅÌÅ¨ Îç∞Ïù¥ÌÑ∞Î°ú ÏµúÎã®Í≤ΩÎ°úÎ•º PolylineÏúºÎ°ú ÏÉùÏÑ±
        const convertedEdges = edges.map((edge, index) => {
          if (!edge.coordinates || edge.coordinates.length === 0) {
            console.error(`‚ö†Ô∏è [ERROR] Edge ID ${edge.id}Ïùò coordinates Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùå!`);
            return null;
          }
        
          return {
            id: edge.id,
            coordinates: edge.coordinates.map(coord => ({
              latitude: coord[1], // ÏúÑÎèÑ
              longitude: coord[0]  // Í≤ΩÎèÑ
            }))
          };
        }).filter(Boolean); // null Ï†úÍ±∞
        
        //ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ Ï∂îÍ∞Ä
        console.log("üì° [DEBUG] Î≥ÄÌôòÎêú Polyline Í≤ΩÎ°ú:", JSON.stringify(convertedEdges, null, 2));
        
        if (convertedEdges.length === 0) {
          console.error("‚ö†Ô∏è [ERROR] Î≥ÄÌôòÎêú Polyline Îç∞Ïù¥ÌÑ∞Í∞Ä ÎπÑÏñ¥ ÏûàÏùå!");
        }
        
        // ÏµúÏ¢Ö polyline Îç∞Ïù¥ÌÑ∞Î•º setPath Ìï®ÏàòÎ•º ÌÜµÌï¥ path stateÏóê Ï†ÄÏû•
        setPath(convertedEdges);
      }
    };
    
    getRoute(); // getRoute Ìï®Ïàò Ïã§Ìñâ
  }, [startLocation, endLocation, nodes]); // ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥: startLocation, endLocation, nodesÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ Ïã§ÌñâÎê®
  // Ï¶â, ÏÉàÎ°úÏö¥ Ï∂úÎ∞úÏßÄ ÎòêÎäî ÎèÑÏ∞©ÏßÄÍ∞Ä ÏÑ§Ï†ïÎêòÍ±∞ÎÇò, ÎÖ∏Îìú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÖÎç∞Ïù¥Ìä∏ Îê† ÎïåÎßàÎã§ getRouteÍ∞Ä Îã§Ïãú Ïã§ÌñâÎê®

  // ÏßÄÎèÑ Í∏∏Í≤å ÎàåÎ†ÄÏùÑ ÎïåÏùò Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ Ìï®Ïàò handleLongPress (ÎπÑÎèôÍ∏∞Ìï®Ïàò)
  // event Í∞ùÏ≤¥Î•º Îß§Í∞úÎ≥ÄÏàòÎ°ú Î∞õÏïÑ, Ìï¥Îãπ ÏúÑÏπò Ï†ïÎ≥¥ ÌôúÏö© 
  const handleLongPress = async (event: any) => {
    const { latitude, longitude } = event.nativeEvent.coordinate; // Í∏∏Í≤å ÎàÑÎ•∏ ÏúÑÏπòÏùò GPS Ï¢åÌëú Í∞ÄÏ†∏Ïò¥
    setSelectedCoords({ latitude, longitude }); // ÏÑ†ÌÉùÎêú Ï¢åÌëúÎ•º selectedCoords stateÏóê Ï†ÄÏû•

    console.log("üìç Í∏∏Í≤å ÎàåÎ¶∞ ÏúÑÏπò (ÏúÑÍ≤ΩÎèÑ):", latitude, longitude);

    // ÏÇ¨Ïö©ÏûêÍ∞Ä Í∏∏Í≤å ÎàÑÎ•∏Í≥≥Ïóê 'Î©îÎâ¥Î•º ÌëúÏãúÌïòÎäî UI'Î•º Î∞∞ÏπòÌïòÍ∏∞ ÏúÑÌï®
    // ÏßÄÎèÑ Ï∞∏Ï°∞ Í∞ùÏ≤¥(mapRef.Current)Í∞Ä Ï°¥Ïû¨ Ïó¨Î∂Ä
    // ÏßÄÎèÑÏôÄ ÏÉÅÌò∏ÏûëÏö© Í∞ÄÎä• Ïó¨Î∂Ä Ï≤¥ÌÅ¨
    if (mapRef.current) {
      try {
        // pointForCoordinate: ÏßÄÎèÑ ÏÉÅÏùò GPS Ï¢åÌëúÎ•º ÌôîÎ©¥ Ï¢åÌëú(ÌîΩÏÖÄ Ï¢åÌëú)Î°ú Î≥ÄÌôòÌïòÎäî React ÎÇ¥Ïû• Î©îÏÑúÎìú
        // Î≥ÄÌôòÎêú ÌôîÎ©¥ Ï¢åÌëúÎ•º pointÏóê Ï†ÄÏû•ÌïòÍ≥†, setMenuPosition Ìï®ÏàòÎ•º ÌÜµÌï¥ menuPosition stateÏóê Ï†ÄÏû•
        const point = await mapRef.current.pointForCoordinate({ latitude, longitude });
        console.log("üì± Î≥ÄÌôòÎêú ÌôîÎ©¥ Ï¢åÌëú (pointForCoordinate):", point);
        setMenuPosition({ x: point.x, y: point.y });
        setMenuVisible(true);
      } catch (error) {
        console.error("üö® Ï¢åÌëú Î≥ÄÌôò Ï§ë Ïò§Î•ò Î∞úÏÉù:", error);
      }
    }
  };

  // Í∏∏Í≤å ÎàÑÎ•∏ ÏúÑÏπò Ï∂úÎ∞úÏßÄÎ°ú ÏÑ§Ï†ï
  // Î©îÎâ¥ÌôîÎ©¥ Îã´Í∏∞
  const setAsStartLocation = () => {
    if (selectedCoords) {
      setStartLocation(selectedCoords);
      setMenuVisible(false);
    }
  };
 
  // Í∏∏Í≤å ÎàÑÎ•∏ ÏúÑÏπò ÎèÑÏ∞©ÏßÄÎ°ú ÏÑ§Ï†ï
  // Î©îÎâ¥ÌôîÎ©¥ Îã´Í∏∞
  const setAsEndLocation = () => {
    if (selectedCoords) {
      setEndLocation(selectedCoords);
      setMenuVisible(false);
    }
  };

  return (
    <Provider>
      <View style={styles.container}>
        <MapView // ÏßÄÎèÑ(MapView)Î•º Î†åÎçîÎßÅÌïòÎäî ÌïµÏã¨ Ïª¥Ìè¨ÎÑåÌä∏
          ref={mapRef} // mapRefÎ•º Ï∞∏Ï°∞Î°ú ÏßÄÏ†ïÌïòÏó¨, Ïô∏Î∂ÄÏóêÏÑú ÏßÄÎèÑ Ï†úÏñ¥ Í∞ÄÎä•
          style={styles.map}
          initialRegion={{ // Ï¥àÍ∏∞ ÏßÄÎèÑ Ï§ëÏã¨ Î∞è Ï§å Î†àÎ≤® ÏÑ§Ï†ï
            latitude: 37.583738,
            longitude: 127.058393,
            latitudeDelta: 0.007,
            longitudeDelta: 0.007,
          }}
          onLongPress={handleLongPress} // Í∏∏Í≤å ÎàåÎ†ÄÏùÑ Îïå, Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ Ìï®Ïàò handleLongPress Ìò∏Ï∂ú
        >
          {/***  Í±¥Î¨º polygon Ìò∏Ï∂ú Î∞è Î†åÎçîÎßÅ ***/}
          {buildingPolygon.map((feature: any, index: number) => { // buildingPolygon Î∞∞Ïó¥ÏùÑ Î∞òÎ≥µÌïòÎ©∞, Í∞Å Í±¥Î¨º Ìè¥Î¶¨Í≥§ÏùÑ ÏßÄÎèÑÏóê ÌëúÏãú
            try {
              const geojson = JSON.parse(feature.geom_json); //feature.geom_jsonÏùÑ JSON.parseÌïòÏó¨ geojsonÏóê Ï†ÄÏû•
              // Polygon ÌÉÄÏûÖÏù¥Î©¥, Ï¢åÌëú Î∞∞Ïó¥ÏùÑ ÌïòÎÇòÏùò Î¶¨Ïä§Ìä∏Î°ú ÎßåÎì¶
              // Polygon ÌÉÄÏûÖÏù¥ ÏïÑÎãàÎ©¥, Ïó¨Îü¨Í∞úÏùò Ìè¥Î¶¨Í≥§ÏùÑ Î†åÎçîÎßÅÌïòÎèÑÎ°ù Î≥ÄÌôò
              const polygons = geojson.type === 'Polygon' ? [geojson.coordinates] : geojson.coordinates;

              // Ìè¥Î¶¨Í≥§Ïùò lng, lat Í∞ìÏùÑ latitude, longitudeÎ°ú Î≥ÄÌôòÌïòÏó¨ coordinatesÏóê Ï†ÄÏû• 
              return polygons.map((polygon: any, i: number) => {
                const coords = polygon[0].map(([lng, lat]: [number, number]) => ({
                  latitude: lat,
                  longitude: lng,
                }));

                // Í±¥Î¨º Ìè¥Î¶¨Í≥§ Î†åÎçîÎßÅ 
                return (
                  <Polygon
                    key={`${index}-${i}`}
                    coordinates={coords}
                    // ÏÑ†ÌÉùÎêú Í±¥Î¨º: ÌååÎûÄÏÉâ, ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏùÄ Í±¥Î¨º: Îπ®Í∞ÑÏÉâ
                    fillColor={selectedBuilding === feature.id ? 'rgba(0, 0, 255, 0.3)' : 'rgba(255, 0, 0, 0.3)'}
                    strokeColor="black"
                    strokeWidth={2}
                    tappable // ÏÇ¨Ïö©ÏûêÍ∞Ä Í±¥Î¨º Ìè¥Î¶¨Í≥§ÏùÑ ÌÅ¥Î¶≠Ìï† Ïàò ÏûàÎèÑÎ°ù ÏÑ§Ï†ï
                    onPress={() => setSelectedBuilding(feature.id)} // Í±¥Î¨º Ìè¥Î¶¨Í≥§ÏùÑ ÌÅ¥Î¶≠ÌñàÏùÑ Îïå, setSelectedBuilding Ìï®Ïàò Ìò∏Ï∂ú
                  />
                );
              });
            } catch (error) {
              console.error(`üö® Ìè¥Î¶¨Í≥§ Î†åÎçîÎßÅ Ïò§Î•ò (Í±¥Î¨º ID: ${feature.id}):`, error);
            }
            return null;
          })}

          {/*** Ï∏µ polygon Ìò∏Ï∂ú Î∞è Î†åÎçîÎßÅ  ***/}
          {floorPolygons.map((feature: any, index: number) => { //feature: Ï∏µ, index: ÌòÑÏû¨ Î∞òÎ≥µÎêòÎäî Ï∏µÏùò Ïù∏Îç±Ïä§
            try {
              const geojson = JSON.parse(feature.geom_json);
              const polygons = geojson.type === 'Polygon' ? [geojson.coordinates] : geojson.coordinates;
              // Í∞Å Ìè¥Î¶¨Í≥§ÏùÑ Í∞úÎ≥Ñ polygon Ïª¥Ìè¨ÎÑåÌä∏Î°ú Î≥ÄÌôò
              return polygons.map((polygon: any, i: number) => (
                <Polygon // Ï∏µ polygon ÏÉùÏÑ±
                  key={`floor-${index}-${i}`} // ReactÏùò Î¶¨Ïä§Ìä∏ ÌÇ§ Í∞í ÏÑ§Ï†ï
                  coordinates={polygon[0].map(([lng, lat]: [number, number]) => ({
                    latitude: lat,
                    longitude: lng,
                  }))}
                  fillColor="rgba(0, 255, 0, 0.3)"
                  strokeColor="black"
                  strokeWidth={2}
                />
              ));
            } catch (error) {
              console.error(`üö® Ï∏µ Ìè¥Î¶¨Í≥§ Î†åÎçîÎßÅ Ïò§Î•ò (Ï∏µ ID: ${feature.id}):`, error);
            }
            return null;
          })}


          {/*** Ï∂úÎ∞úÏßÄ & ÎèÑÏ∞©ÏßÄ ÎßàÏª§ ***/}
          {startLocation && (
            <Marker coordinate={startLocation} title="Ï∂úÎ∞úÏßÄ" pinColor="blue" />
          )}
          {endLocation && (
            <Marker coordinate={endLocation} title="ÎèÑÏ∞©ÏßÄ" pinColor="red" />
          )}


          {/***  ÏµúÎã® Í≤ΩÎ°ú Í∞ÄÏãúÌôî(polyline) ***/}
          {path.map((edge, index) => (
  <Polyline
    key={edge.id || index}  // IDÍ∞Ä ÏóÜÏúºÎ©¥ Ïù∏Îç±Ïä§ ÏÇ¨Ïö©
    coordinates={edge.coordinates}
    strokeWidth={5}
    strokeColor="#00BFFF"
  />
))}

        </MapView>

        {/*** Ï∂úÎ∞ú, ÎèÑÏ∞©ÏßÄ ÏÑ†ÌÉù Î©îÎâ¥ Î†åÎçîÎßÅ ***/} 
        {menuVisible && menuPosition && ( // handleLongPress ÏÉÅÌô©ÏóêÏÑúÎßå Î†åÎçîÎßÅ
          <View style={{ position: 'absolute', left: menuPosition.x, top: menuPosition.y }}>
            {console.log("üì± Î©îÎâ¥ ÏúÑÏπò (ÌîΩÏÖÄ):", menuPosition.x, menuPosition.y)}

            <Menu
              visible={menuVisible}
              onDismiss={() => setMenuVisible(false)}
              anchor={<View style={{ width: 1, height: 1 }} />}
            >
              <Menu.Item onPress={setAsStartLocation} title="Ï∂úÎ∞úÏßÄÎ°ú ÏÑ§Ï†ï" />
              <Menu.Item onPress={setAsEndLocation} title="ÎèÑÏ∞©ÏßÄÎ°ú ÏÑ§Ï†ï" />
            </Menu>
          </View>
        )}
      </View>
    </Provider>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1 },
  map: { flex: 1 },
});

export default MapComponent;
